<?php

/**
 * BP-MEDIA TRIE UTILITIES CLASS
 * Provides utility functions for manipulating trie data structures
 *
 * @version 0.1.9
 * @since 0.1.9
 * @package FoxFire
 * @subpackage Hash Table
 * @license GPL v2.0
 * @link http://code.google.com/p/buddypress-media/
 *
 * ========================================================================================================
 */

class FOX_trie {


	public function __construct(){}
		
	
	/**
	 * Flattens a trie structure to matrix
	 *
	 * @version 0.1.9
	 * @since 0.1.9
	 *
	 * @param array $trie | Trie structure
	 * @param array $columns | Array of column names
	 * @param array $ctrl | Control args
	 * 
	 * @return array | Exception on failure. Flattened trie structure on success.
	 */

	public static function flattenAssocTrie($trie, $columns, $ctrl){

	    
		try {
			$cls = new FOX_trie_flatten($trie, $columns, $ctrl);
		}
		catch (FOX_exception $child) {
		    
			throw new FOX_exception( array(
				'numeric'=>1,
				'text'=>"Error creating iterator object",
				'file'=>__FILE__, 'line'=>__LINE__, 'method'=>__METHOD__,
				'child'=>$child
			));		    
		}				
		
		try {
			$result = $cls->render();
		}
		catch (FOX_exception $child) {
		    
			throw new FOX_exception( array(
				'numeric'=>2,
				'text'=>"Error rendering to array",
				'file'=>__FILE__, 'line'=>__LINE__, 'method'=>__METHOD__,
				'child'=>$child
			));		    
		}
		
		return $result;
		
	}
	
	
	/**
	 * Clips trie branches at the first null node in a walk. This method is used to
	 * determine the cache levels to invalidate during delete operations.
	 * 
	 * BEFORE:  A --> B -> C	AFTER:	A --> B -> C
	 *	      |-> * -> E		  |-> D
	 *	      |-> D -> *
	 * 
	 * @version 0.1.9
	 * @since 0.1.9
	 *
	 * @param array $trie | Trie structure
	 * 
	 * @param array $columns | Array of column names
	 *
	 * @param array $ctrl | Control args 
	 *	=> VAL @param string $null_token | String to use as null token 	  
	 * 
	 * @return array | Exception on failure. Clipped trie structure on success.
	 */
	
	public static function clipAssocTrie($trie, $columns, $ctrl=null){
	    
	    
		$ctrl_default = array(
			'null_token' => '*'
		);

		$ctrl = wp_parse_args($ctrl, $ctrl_default);
		
		try {
			$cls = new FOX_trie_clip($trie, $columns, $ctrl);
		}
		catch (FOX_exception $child) {
		    
			throw new FOX_exception( array(
				'numeric'=>1,
				'text'=>"Error creating iterator object",
				'file'=>__FILE__, 'line'=>__LINE__, 'method'=>__METHOD__,
				'child'=>$child
			));		    
		}				
		
		try {
			$result = $cls->render();
		}
		catch (FOX_exception $child) {
		    
			throw new FOX_exception( array(
				'numeric'=>2,
				'text'=>"Error rendering to array",
				'file'=>__FILE__, 'line'=>__LINE__, 'method'=>__METHOD__,
				'child'=>$child
			));		    
		}
		
		return $result;
		
		
	}	
	
	
	/**
	 * Returns the optimal key ordering sequence for a flat array
	 *
	 * @version 0.1.9
	 * @since 0.1.9
	 *
	 * @param array $rows | Flat matrix
	 * @param array $columns | Array of column names
	 * @param array $ctrl | Control args
	 * 
	 * @return array | Exception on failure. Optimized columns matrix on success.
	 */
	
	public static function optimizeMatrix($rows, $columns, $ctrl=null){
	    
	    
		// Re-order the key columns FIRST by DESCENDING density (total number of keys in 
		// a column) and SECOND by ASCENDING entropy (number of unique keys in a column).
		// This creates an optimum trie structure during the lofting step which dramatically
		// reduces the WHERE clause complexity generated by the recursive iterators.			   	    	    

		// BEFORE: IF ("A" AND "B" ) OR ("A" AND "C")
		// AFTER:  IF "A" AND ("B" OR "C")

		// @see http://en.wikipedia.org/wiki/Determinant
		// @see http://en.wikipedia.org/wiki/Diagonal_matrix

		$entropy_sort = array();

		// Set the bias to be the total number of rows in the args matrix. This
		// causes the key columns to be sorted first by the NULL count of the 
		// column, then by the column's entropy

		$bias = count($rows);

		foreach($columns as $key){

			$temp = array();
			$column_bias = 0;

			foreach( $rows as $row ){

				if(FOX_sUtil::keyExists($key, $row)){

					$temp[] = $row[$key];
				}
				else {
					$column_bias += $bias;
				}

			}
			unset($row);

			$temp = array_unique($temp);
			$entropy_sort[$key] = count($temp) + $column_bias;

		}
		unset($key);

		asort($entropy_sort);			

		return array_keys($entropy_sort);	
		
	}
	
	
	/**
	 * Lofts a flat matrix into a trie structure
	 *
	 * @version 0.1.9
	 * @since 0.1.9
	 *
	 * @param array $rows | Flat matrix
	 * @param array $columns | Array of column names
	 * @param array $ctrl | Control args
	 * 
	 * @return array | Exception on failure. Flattened trie structure on success.
	 */
	
	public static function loftMatrix($rows, $columns, $ctrl=null){
	    	   
	    
		$ctrl_default = array(
			'null_token' => '*'
		);

		$ctrl = wp_parse_args($ctrl, $ctrl_default);
		
		$result = array();

		// If a single column name is passed as a string, use the more efficient
		// direct assignment algorithm to build a 1 level trie

		if( !is_array($columns) ){

			foreach($rows as $row){

				// Convert row object into array
				foreach($row as $tokens){

					$result[$tokens[$columns]] = true;					
				}
				unset($tokens);

			}
			unset($row);
		}

		// If an array of column names are passed, use the less efficient eval()
		// algorithm to build a n-level deep trie

		else {

			foreach($rows as $row){

				// Since there is no functionality in PHP for creating a new array key
				// based on a name stored in a variable ( $$ variable variable syntax does
				// not work for multidimensional arrays), we have to build a string of PHP
				// code and use eval() to run it

				$eval_str = "\$result";

				foreach($columns as $keyname){

					if(FOX_sUtil::keyExists($keyname, $row)){

						$eval_str .= '["' . $row[$keyname] . '"]';						
					}
					else {
						$eval_str .= '["' . $ctrl['null_token'] . '"]';
					}				    

				}
				unset($keyname);

				$eval_str .= " = true;";

				// Run the PHP string we have built
				eval($eval_str);

			}
			unset($row);

		}
		
		return $result;
			
	}	
	
	

	
	
	/**
	 * Lofts a flat matrix into a trie structure, while hashing its keys
	 *
	 * @version 0.1.9
	 * @since 0.1.9
	 *
	 * @param array $rows | Flat matrix
	 * @param array $columns | Array of column names
	 * @param array $ctrl | Control args
	 * 
	 * @return array | Exception on failure. Flattened trie structure on success.
	 */
	
	public static function loftMatrixHash($rows, $columns, &$hash_table, $ctrl=null){
	    	   

		$ctrl_default = array(
			'null_token' => '*'
		);

		$ctrl = wp_parse_args($ctrl, $ctrl_default);
		
		$result = array();

		// If a single column name is passed as a string, use the more efficient
		// direct assignment algorithm to build a 1 level trie

		if( !is_array($columns) ){

			foreach($rows as $row){

				// Convert row object into array
				foreach($row as $tokens){

					$result[$hash_table->set($tokens[$columns])] = true;						    
				}
				unset($tokens);

			}
			unset($row);
		}

		// If an array of column names are passed, use the less efficient eval()
		// algorithm to build a n-level deep trie

		else {

			foreach($rows as $row){

				// Since there is no functionality in PHP for creating a new array key
				// based on a name stored in a variable ( $$ variable variable syntax does
				// not work for multidimensional arrays), we have to build a string of PHP
				// code and use eval() to run it

				$eval_str = "\$result";

				foreach($columns as $keyname){

					if(FOX_sUtil::keyExists($keyname, $row)){

						$eval_str .= '["' . $hash_table->set($row[$keyname]) . '"]';							

					}
					else {
						$eval_str .= '["' . $ctrl['null_token'] . '"]';
					}				    

				}
				unset($keyname);

				$eval_str .= " = true;";

				// Run the PHP string we have built
				eval($eval_str);

			}
			unset($row);

		}
		
		return $result;
			
	}		
	


	
} // End of class FOX_trie

?>